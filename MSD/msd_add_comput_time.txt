#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "xparameters.h"
#include "msd_33.h"
#include "xil_io.h"
#include "sleep.h"
#include "stdlib.h"
#include "stdint.h"
#include "math.h"
#include "xtime_l.h"
#define max(a, b) ((a) > (b) ? (a) : (b))
#define START_ADDRESS 0x43c00000
#define END_ADDRESS 0x43FB0000
#define STEP_SIZE 0x10000 // 假设步长为 0x10000
#define ROWS 60
#define COLS 3
#define ARRAY_SIZE 60

long long* generate_random_array(long long* array, int size, int random_seed) {
    long long lower_bound = (1LL << 32) - 1;  // 2^32 - 1
    long long upper_bound = (1LL << 33) - 1;  // 2^33 - 1
    srand(random_seed);

    // 生成随机数并存储在数组中
    for (int i = 0; i < size; ++i) {
        array[i] = ((long long)rand() % (upper_bound - lower_bound + 1)) + lower_bound;
    }

    return array;
}
void decToBin(long long dec, int bin[])
{
    if (dec < 0)
    {
        dec *= -1;
        bin[0] = 1; // 0代表正，1代表负
    }
    else
    {
        bin[0] = 0;
    }
    long long num = dec;

    int temp[99];
    int i;
    for (i = 0; num != 0; i++)
    {
        temp[i] = num % 2; // 使用 % 运算符计算余数
        num /= 2;
    }
    for (int j = 1, index = i - 1; j <= i; j++, index--)
    {
        bin[j] = temp[index];
    }
    bin[i + 1] = -2; // 结束标志
}

void binToMsd(int bin[], int msd[])
{
    int index_msd = 0;
    if (bin[0] == 1)
    {
        for (int index_bin = 1; bin[index_bin] != -2; index_bin++, index_msd++)
        {
            msd[index_msd] = 0;
            if (bin[index_bin] == 1)
                msd[index_msd] = -1;
        }
        msd[index_msd] = -2; // 结束标志
    }
    else
    {
        for (int index_bin = 1; bin[index_bin] != -2; index_bin++, index_msd++)
        {
            msd[index_msd] = bin[index_bin];
        }
        msd[index_msd] = -2; // 结束标志
    }
}

int bin_to_dec(char bin[], int len)
{
    int result = 0, base = 1;
    for (int i = len - 1; i >= 0; i--, base = base * 2)
        result = result + (bin[i] - '0') * base;
    return result;
}

long long msdToDec(int msd[])
{
    long long result = 0;
    int len = 0;
    for (; msd[len] != -2; len++)
        ;

    for (int i = 0, j = len - 1; i < len; i++, j--)
    {
        long long t = 1;
        for (int k = 0; k < j; k++)
        {
            t *= 2;
        }
        result += msd[i] * t;
    }
    return result;
}

void convertToBinaryString(int *msd, char *result)
{
    int i = 0;
    while (msd[i] != -2)
    {
        if (msd[i] == 0)
        {
            strcat(result, "00");
        }
        else if (msd[i] == 1)
        {
            strcat(result, "01");
        }
        else if (msd[i] == -1)
        {
            strcat(result, "10");
        }
        i++;
    }
}

void binaryStringToMSD(char *binaryString, int *intArray, int length)
{
    for (int i = 0; i < length; i++)
    {
        char tmp[3];
        strncpy(tmp, binaryString + i * 2, 2);
        tmp[2] = '\0';

        if (strcmp(tmp, "00") == 0)
        {
            intArray[i] = 0;
        }
        else if (strcmp(tmp, "01") == 0)
        {
            intArray[i] = 1;
        }
        else if (strcmp(tmp, "10") == 0)
        {
            intArray[i] = -1;
        }
        // Add more conditions as needed
    }
}

void cdecToBin(unsigned value, int bits, char *binaryArray)
{
    for (int i = bits - 1; i >= 0; i--)
    {
        binaryArray[bits - 1 - i] = ((value >> i) & 1) + '0';
    }
    binaryArray[bits] = '\0'; // 添加 null 终止符
}

void write_reg(unsigned int  array[][3], long long value,int row) {
    int bin[36];
    int msd[36];
    decToBin(value, bin);
    binToMsd(bin, msd);
    char z[67] = "";
    convertToBinaryString(msd, z);
    int len_z = strlen(z);
    if (len_z <= 32)
    {
        array[row][0] = bin_to_dec(z, len_z);
    }
    else if (len_z > 32 && len_z <= 64)
    {
        array[row][0] = bin_to_dec(z + len_z - 32, 32);
        array[row][1] = bin_to_dec(z, len_z - 32);
    }
    else if (len_z > 64 && len_z <= 96)
    {
        array[row][0] = bin_to_dec(z + len_z - 32, 32);
        array[row][1] = bin_to_dec(z + len_z - 64, 32);
        array[row][2] = bin_to_dec(z, len_z - 64);
    }
}
void printUnsignedArray(unsigned int array[][3], int rows, int cols) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            printf("%u ", array[i][j]);
        }
        printf("\n");
    }
}

void regToDec(unsigned int decresult[][3],long long * ansDec,int index){
    char ans_c[70] = "";
    cdecToBin(decresult[index][2], 6, ans_c);
    cdecToBin(decresult[index][1], 32, ans_c + 6);
    cdecToBin(decresult[index][0], 32, ans_c + 38);
    int msd_c[40];

    int length = strlen(ans_c) / 2; // Assuming the length is even
    binaryStringToMSD(ans_c, msd_c, length);
    msd_c[length] = -2;
    ansDec[index] = msdToDec(msd_c);
}

void printLongLongArray(long long array[], int length) {
    for (int i = 0; i < length; ++i) {
        printf("%lld ", array[i]);
    }
    printf("\n");
}

int main() {
    long long array_a[ARRAY_SIZE];
    long long array_b[ARRAY_SIZE];
    int arrayLength = (END_ADDRESS - START_ADDRESS) / STEP_SIZE + 1;
    int deviceAddresses[arrayLength];
    int currentAddress = START_ADDRESS;
    for (int i = 0; i < arrayLength; ++i) {
        deviceAddresses[i] = currentAddress;
        currentAddress += STEP_SIZE;
    }
    XTime tEnd, tbegin;
    u32 tused;
    long long* data_a = generate_random_array(array_a, ARRAY_SIZE,123);
    long long* data_b = generate_random_array(array_b, ARRAY_SIZE,456);
    unsigned int reg_a[ROWS][COLS] = { {0} };
    unsigned int reg_b[ROWS][COLS] = { {0} };
    for(int i=0;i<ROWS;i++){
    	write_reg(reg_a,data_a[i],i);
    	write_reg(reg_b,data_b[i],i);
    }
    int k_reg[9]={0};
    unsigned int decresult[ROWS][COLS] = { {0} };

	for (int k = 0; k < 9; k++)
	{
		k_reg[k] = k * 4;
	}

    XTime_GetTime(&tbegin);
	for(int i=0;i<60;i++){
		MSD_33_mWriteReg(deviceAddresses[i], k_reg[0], reg_a[i][0]);
		MSD_33_mWriteReg(deviceAddresses[i], k_reg[1], reg_a[i][1]);
		MSD_33_mWriteReg(deviceAddresses[i], k_reg[2], reg_a[i][2]);
		MSD_33_mWriteReg(deviceAddresses[i], k_reg[3], reg_b[i][0]);
		MSD_33_mWriteReg(deviceAddresses[i], k_reg[4], reg_b[i][1]);
		MSD_33_mWriteReg(deviceAddresses[i], k_reg[5], reg_b[i][2]);
		decresult[i][0] = MSD_33_mReadReg(deviceAddresses[i], k_reg[6]);
		decresult[i][1] = MSD_33_mReadReg(deviceAddresses[i], k_reg[7]);
		decresult[i][2] = MSD_33_mReadReg(deviceAddresses[i], k_reg[8]);
	}
	XTime_GetTime(&tEnd);
    tused = ((tEnd-tbegin)*1000000)/(COUNTS_PER_SECOND);

	long long ansDec[ROWS] = {0};
	for(int i=0;i<ROWS;i++){
		regToDec(decresult,ansDec,i);
	}
	for(int i=0;i<60;i++){
		printf("%lld + %lld = %lld   ",data_a[i],data_b[i],ansDec[i]);
		if((i+1)%2==0){
			printf("\n");
		}
	}
	xil_printf("%d msd additions ,time elapsed is %d us\r\n",ROWS,tused);
	float tused_float = (float)tused / 60.0;
	printf("average time per msd addition is  %f\n", tused_float);
    return 0;
}
